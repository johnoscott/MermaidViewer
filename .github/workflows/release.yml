# MermaidViewer Release Workflow
#
# Builds, code-signs, notarizes, and publishes MermaidViewer as a DMG to GitHub Releases.
#
# Triggers:
#   - Tag push matching v* (e.g., v1.0.0)
#   - Manual dispatch with a version input
#
# Required GitHub Secrets:
#   DEVELOPER_ID_CERTIFICATE_P12       - Base64-encoded Developer ID Application certificate (.p12)
#   DEVELOPER_ID_CERTIFICATE_PASSWORD  - Password for the .p12 file
#   APPLE_TEAM_ID                      - Apple Developer Team ID (e.g., KJ8QMLWB97)
#   NOTARY_API_KEY_ID                  - App Store Connect API Key ID
#   NOTARY_API_KEY_ISSUER_ID           - App Store Connect API Issuer ID
#   NOTARY_API_KEY                     - Base64-encoded App Store Connect API private key (.p8)
#   HOMEBREW_TAP_TOKEN                 - Personal access token with repo scope for johnoscott/homebrew-mermaid-viewer
#
# To set up secrets:
#   1. Export your Developer ID Application cert as .p12 from Keychain Access
#   2. base64 -i certificate.p12 | pbcopy  → paste as DEVELOPER_ID_CERTIFICATE_P12
#   3. Create an App Store Connect API key at https://appstoreconnect.apple.com/access/api
#   4. base64 -i AuthKey_XXXXXX.p8 | pbcopy  → paste as NOTARY_API_KEY

name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true
        type: string

env:
  SCHEME: MermaidViewer
  APP_NAME: MermaidViewer.app
  DMG_NAME: MermaidViewer

jobs:
  build-sign-release:
    name: Build, Sign & Release
    runs-on: macos-15
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF_NAME#v}"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=v$VERSION" >> "$GITHUB_OUTPUT"
          echo "Version: $VERSION"

      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Import code signing certificate
        env:
          P12_BASE64: ${{ secrets.DEVELOPER_ID_CERTIFICATE_P12 }}
          P12_PASSWORD: ${{ secrets.DEVELOPER_ID_CERTIFICATE_PASSWORD }}
        run: |
          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$P12_BASE64" | base64 --decode > "$CERT_PATH"

          security import "$CERT_PATH" \
            -P "$P12_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Set key partition list for codesign access
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add temporary keychain to search list
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')
          security default-keychain -s "$KEYCHAIN_PATH"

          # Verify certificate was imported
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          # Save keychain path for cleanup
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

      - name: Set up App Store Connect API key for signing
        run: |
          # Create the API key directory expected by xcodebuild
          mkdir -p "$RUNNER_TEMP/private_keys"
          echo "${{ secrets.NOTARY_API_KEY }}" | base64 --decode \
            > "$RUNNER_TEMP/private_keys/AuthKey_${{ secrets.NOTARY_API_KEY_ID }}.p8"
          echo "API_KEY_PATH=$RUNNER_TEMP/private_keys/AuthKey_${{ secrets.NOTARY_API_KEY_ID }}.p8" >> "$GITHUB_ENV"

      - name: Generate Xcode project
        run: xcodegen generate

      - name: Build & Archive
        run: |
          # Archive with ad-hoc signing to preserve hardened runtime.
          # The export step re-signs with Developer ID Application.
          xcodebuild archive \
            -scheme "$SCHEME" \
            -configuration Release \
            -archivePath "$RUNNER_TEMP/MermaidViewer.xcarchive" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY=- \
            CODE_SIGNING_REQUIRED=NO \
            DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}" \
            MARKETING_VERSION="${{ steps.version.outputs.version }}" \
            CURRENT_PROJECT_VERSION="${GITHUB_RUN_NUMBER}" \
            ENABLE_HARDENED_RUNTIME=YES

      - name: Export archive
        run: |
          # Generate ExportOptions.plist for Developer ID re-signing
          cat > "$RUNNER_TEMP/ExportOptions.plist" <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>developer-id</string>
            <key>teamID</key>
            <string>${{ secrets.APPLE_TEAM_ID }}</string>
            <key>signingCertificate</key>
            <string>Developer ID Application</string>
          </dict>
          </plist>
          PLIST

          xcodebuild -exportArchive \
            -archivePath "$RUNNER_TEMP/MermaidViewer.xcarchive" \
            -exportPath "$RUNNER_TEMP/export" \
            -exportOptionsPlist "$RUNNER_TEMP/ExportOptions.plist" \
            -allowProvisioningUpdates \
            -authenticationKeyPath "$API_KEY_PATH" \
            -authenticationKeyID "${{ secrets.NOTARY_API_KEY_ID }}" \
            -authenticationKeyIssuerID "${{ secrets.NOTARY_API_KEY_ISSUER_ID }}"

      - name: Re-sign extensions with required entitlements
        run: |
          # Developer ID export doesn't inject com.apple.application-identifier
          # and com.apple.developer.team-identifier, which are required for
          # macOS to register Quick Look/Thumbnail extensions via pluginkit.
          #
          # IMPORTANT: Only re-sign the extensions (appex), not the main app.
          # com.apple.application-identifier is a restricted entitlement that
          # requires a provisioning profile — AMFI blocks app launch without one.
          # Extensions loaded by the system are handled differently.
          TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"
          EXPORT="$RUNNER_TEMP/export/$APP_NAME"
          PLUGINS="$EXPORT/Contents/PlugIns"

          generate_extension_entitlements() {
            local bundle_id="$1"
            local file="$2"
            cat > "$file" <<ENTITLEMENTS
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>com.apple.application-identifier</key>
            <string>${TEAM_ID}.${bundle_id}</string>
            <key>com.apple.developer.team-identifier</key>
            <string>${TEAM_ID}</string>
            <key>com.apple.security.app-sandbox</key>
            <true/>
            <key>com.apple.security.application-groups</key>
            <array>
              <string>group.com.roundrect.mermaidviewer</string>
            </array>
            <key>com.apple.security.files.user-selected.read-only</key>
            <true/>
          </dict>
          </plist>
          ENTITLEMENTS
          }

          # Save main app's original entitlements before re-signing extensions
          codesign -d --entitlements "$RUNNER_TEMP/app-entitlements.xml" "$EXPORT" 2>/dev/null

          # Re-sign extensions with application-identifier
          echo "==> Re-signing MermaidQuickLook.appex..."
          generate_extension_entitlements "com.roundrect.mermaidviewer.quicklook" \
            "$RUNNER_TEMP/ql-entitlements.plist"
          codesign --force --sign "Developer ID Application" \
            --options runtime \
            --entitlements "$RUNNER_TEMP/ql-entitlements.plist" \
            "$PLUGINS/MermaidQuickLook.appex"

          echo "==> Re-signing MermaidThumbnail.appex..."
          generate_extension_entitlements "com.roundrect.mermaidviewer.thumbnail" \
            "$RUNNER_TEMP/thumb-entitlements.plist"
          codesign --force --sign "Developer ID Application" \
            --options runtime \
            --entitlements "$RUNNER_TEMP/thumb-entitlements.plist" \
            "$PLUGINS/MermaidThumbnail.appex"

          # Re-sign main app with its ORIGINAL entitlements
          # (nested code change invalidates parent signature)
          echo "==> Re-signing MermaidViewer.app (preserving original entitlements)..."
          codesign --force --sign "Developer ID Application" \
            --options runtime \
            --entitlements "$RUNNER_TEMP/app-entitlements.xml" \
            "$EXPORT"

          echo "==> Verifying entitlements..."
          codesign -d --entitlements - "$PLUGINS/MermaidQuickLook.appex" 2>&1 | grep application-identifier
          codesign -d --entitlements - "$PLUGINS/MermaidThumbnail.appex" 2>&1 | grep application-identifier
          echo "==> Main app entitlements (should NOT have application-identifier):"
          codesign -d --entitlements - "$EXPORT" 2>&1

      - name: Verify code signing
        run: |
          echo "==> Checking code signature..."
          codesign -dvvv "$RUNNER_TEMP/export/$APP_NAME"
          echo ""
          echo "==> Verifying signature..."
          codesign --verify --deep --strict "$RUNNER_TEMP/export/$APP_NAME"

      - name: Notarize app
        run: |
          # Create a zip for notarization submission
          ditto -c -k --keepParent \
            "$RUNNER_TEMP/export/$APP_NAME" \
            "$RUNNER_TEMP/MermaidViewer-notarize.zip"

          # Submit for notarization
          xcrun notarytool submit \
            "$RUNNER_TEMP/MermaidViewer-notarize.zip" \
            --key "$API_KEY_PATH" \
            --key-id "${{ secrets.NOTARY_API_KEY_ID }}" \
            --issuer "${{ secrets.NOTARY_API_KEY_ISSUER_ID }}" \
            --wait \
            --timeout 30m \
            2>&1 | tee "$RUNNER_TEMP/notarytool-output.txt"

          # Extract submission ID for potential log retrieval
          SUBMISSION_ID=$(grep -o '[0-9a-f\-]\{36\}' "$RUNNER_TEMP/notarytool-output.txt" | head -1)
          echo "SUBMISSION_ID=$SUBMISSION_ID" >> "$GITHUB_ENV"

          # Check if notarization succeeded
          if grep -q "status: Invalid" "$RUNNER_TEMP/notarytool-output.txt"; then
            echo "==> Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --key "$API_KEY_PATH" \
              --key-id "${{ secrets.NOTARY_API_KEY_ID }}" \
              --issuer "${{ secrets.NOTARY_API_KEY_ISSUER_ID }}" \
              "$RUNNER_TEMP/notarization-log.json"
            cat "$RUNNER_TEMP/notarization-log.json"
            exit 1
          fi

          # Staple the notarization ticket to the app
          xcrun stapler staple "$RUNNER_TEMP/export/$APP_NAME"

          # Verify stapling
          xcrun stapler validate "$RUNNER_TEMP/export/$APP_NAME"

      - name: Create DMG
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DMG_FILE="${DMG_NAME}-${VERSION}.dmg"

          # Create a temporary directory for DMG contents
          DMG_STAGING="$RUNNER_TEMP/dmg-staging"
          mkdir -p "$DMG_STAGING"

          # Copy the notarized app
          cp -R "$RUNNER_TEMP/export/$APP_NAME" "$DMG_STAGING/"

          # Create Applications symlink for drag-install
          ln -s /Applications "$DMG_STAGING/Applications"

          # Create the DMG
          hdiutil create \
            -volname "$DMG_NAME" \
            -srcfolder "$DMG_STAGING" \
            -ov \
            -format UDZO \
            "$RUNNER_TEMP/$DMG_FILE"

          echo "DMG_FILE=$DMG_FILE" >> "$GITHUB_ENV"
          echo "DMG_PATH=$RUNNER_TEMP/$DMG_FILE" >> "$GITHUB_ENV"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"

          # Create tag if triggered by workflow_dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git tag "$TAG" || true
            git push origin "$TAG" || true
          fi

          # Create the release with the DMG
          gh release create "$TAG" \
            "$DMG_PATH#MermaidViewer ${VERSION} (DMG)" \
            --title "MermaidViewer $VERSION" \
            --generate-notes

      - name: Update Homebrew cask
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          if [ -z "$HOMEBREW_TAP_TOKEN" ]; then
            echo "::warning::HOMEBREW_TAP_TOKEN not set, skipping Homebrew cask update"
            exit 0
          fi

          VERSION="${{ steps.version.outputs.version }}"
          SHA256=$(shasum -a 256 "$DMG_PATH" | awk '{print $1}')

          echo "Version: $VERSION"
          echo "SHA256: $SHA256"

          # Clone the Homebrew tap repo
          git clone "https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/johnoscott/homebrew-mermaid-viewer.git" \
            "$RUNNER_TEMP/homebrew-tap"

          cd "$RUNNER_TEMP/homebrew-tap"

          # Update version and sha256 in the cask formula
          sed -i '' "s/version \".*\"/version \"$VERSION\"/" Casks/mermaid-viewer.rb
          sed -i '' "s/sha256 \".*\"/sha256 \"$SHA256\"/" Casks/mermaid-viewer.rb

          # Commit and push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Casks/mermaid-viewer.rb
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "Update mermaid-viewer to $VERSION"
          git push

      - name: Clean up keychain
        if: always()
        run: |
          if [ -n "$KEYCHAIN_PATH" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          fi
